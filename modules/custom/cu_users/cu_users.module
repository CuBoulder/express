<?php

/**
 * @file
 * CU Users Module containing users/roles and permissions for CU-FIT clones.
 */

/**
 * Returns an array of that type of user.
 *
 * @param string $type
 *   Which set of accounts to return.
 *
 * @return array
 *   Associative array of user accounts.
 */
function cu_users_get_users($type = 'all') {

  $user_array['developer'] = array(
    'crafts' => 'Kevin.Crafts@Colorado.EDU',
    'sniderc' => 'Catherine.Snider@Colorado.EDU',
    'kere7580' => 'Kevin.Reynen@Coloardo.EDU',
    'jafu6031' => 'James.W.Fuller@Colorado.EDU',
    'alfi2595' => 'alexander.finnarn@colorado.edu',
    'owmo7772' => 'owen.morrill@colorado.edu',
    'jeor0980' => 'Jesus.OrtizTovar@colorado.edu',
    'osr-test-sis' => 'osr-test-sis@colorado.edu'
  );

  $user_array['administrator'] = array(
    'brokaw' => 'Annie.Brokaw@Colorado.EDU',
    'leslie' => 'jon.leslie@Colorado.EDU',
    'linebarg' => 'joanna.bertrand@Colorado.EDU',
    'wetu1300' => 'wendy.turnbull@Colorado.EDU',
    'mortone' => 'Emily.Kellagher@Colorado.EDU',
  );

  $user_array['site_owner'] = array(
    'osr-test-owner' => 'osr-test-owner@colorado.edu',
  );

  $user_array['content_editor'] = array(
    'osr-test-content' => 'osr-test-content@colorado.edu',
  );

  $user_array['edit_my_content'] = array(
    'osr-test-edit-own' => 'osr-test-edit-own@colorado.edu',
  );

  $user_array['all'] = array_merge($user_array['developer'], $user_array['administrator'], $user_array['site_owner'], $user_array['content_editor'], $user_array['edit_my_content']);

  return $user_array[$type];
}

/**
 * Checks to see if a specific user is a developer or admin.
 *
 * @param string $username
 *   The username to check.
 *
 * @return bool
 *   TRUE if user is admin or developer, FALSE otherwise.
 */
function cu_users_check_user($username) {
  $users = cu_users_get_users('all');
  if (array_key_exists($username, $users)) {
    return TRUE;
  }

  return FALSE;
}

/**
 * Implements hook_help().
 */
function cu_users_help($path, $arg) {
  switch ($path) {
    case 'admin/people/invite':
      return '<p>' . t("Any CU-Boulder employee, student, or sponsored vendor with an IdentiKey can be granted access to the website administration area. To add new users, select a role and add the users' colorado.edu email address. You can send multiple invites by separating email addresses with a comma (i.e. jane.doe@colorado.edu, joe.smith@colorado.edu). Once submitted an email will be sent inviting the users.") .
        '</p><p>' . t("<strong>Site Owner:</strong> Main authority/contact for the website. All site access permissions. Limited to 3 people. Held responsible for the website adhering to university policies.") .
        '</p><p>' . t("<strong>Site Editor:</strong> Main site builder. Full access to website content and layout tools. Trusted user responsible for the day-to-day maintenance and building of the website. Can receive elevated add-on roles.") .
        '</p><p>' . t("<strong>Content Editor:</strong> Edit only access. A basic role limited to content edits/updates for existing content. Canâ€™t delete or add content, blocks or layouts.") .
        '</p><p>' . t('<strong>Edit My Content:</strong> Page specific access. A basic role limited to content edits/updates for specific pages. Can receive limited add-on roles.') .
        '</p><br/>';
  }
}

/**
 * Implements hook_menu_alter().
 */
function cu_users_menu_alter(&$items) {
  $items['admin/config']['access callback'] = 'user_access';
  $items['admin/config']['access arguments'] = array('access configuration administration');
  $items['admin/structure/block']['access callback'] = 'user_access';
  $items['admin/structure/block']['access arguments'] = array('access configuration administration');
}

/**
 * Implements hook_permission().
 */
function cu_users_permission() {
  return array(
    'access configuration administration' => array(
      'title' => 'Access Configuration Administration',
      'restrict access' => TRUE,
      'description' => 'Access admin/configuration',
    ),
  );
}

/**
 * Implements hook_cron().
 *
 * Expire user sessions nightly between 2AM and 3AM.
 */
function cu_users_cron() {

  $time_zone = date_default_timezone_get();

  // Set timezone to Denver if not set already.
  if ($time_zone != 'America/Denver') {
    date_default_timezone_set('America/Denver');
  }

  // Get hour of the day in 0 to 23 format.
  $hours = date("H");

  // If hour is 2 meaning between 2AM and 3AM delete user sessions
  // This assumes cron runs every 20 minutes or at least a couple times and
  // hour.
  if ($hours == 02) {
    $deleted_rows = db_delete('sessions')->execute();

    // Write to the watchdog just in case this becomes a stat in the future.
    watchdog('cron', 'Number of sessions deleted: %deleted_rows', array('%deleted_rows' => $deleted_rows));
  }
}

/**
 * Check if user has role name.
 *
 * @param string $role_name
 *   The role to check for.
 * @param object $user
 *   The user object to check against.
 *
 * @return bool
 *   TRUE if user has role, FALSE otherwise.
 */
function cu_users_user_has_role($role_name, $user = NULL) {
  if ($user == NULL) {
    global $user;
  }
  if (is_array($user->roles) && in_array($role_name, array_values($user->roles))) {
    return TRUE;
  }
  return FALSE;
}

/**
 * Implements hook_views_pre_render().
 *
 * Hide developers, administrators, and test accounts on the Users overview page
 * from lesser roles.
 */
function cu_users_views_pre_render(&$view) {
  if ($view->name == 'cu_people_administration_override_view') {
    $account = $GLOBALS['user'];
    // If the current user is an administrator or developer, then don't alter
    // the view results.
    if ($account->uid == 1 || cu_users_user_has_role('developer', $account)) {
      return;
    }
    // Load all of the view results at once to avoid making hundreds of calls to
    // load users.
    $uids = array_map(function ($var) {
      return $var->uid;
    }, $view->result);
    $users = user_load_multiple($uids);
    // $view-result is keyed by 0, whereas the loaded users are keyed by id,
    // so let's use a for loop to walk through the loaded users and unset the
    // matching view results.
    for ($x = 0; $x < count($users); $x++) {
      $user = current($users);
      // Hide developer, administrator, and test accounts.
      if (in_array('developer', $user->roles) ||
        in_array('administrator', $user->roles) ||
        (strpos($user->name, 'osr') === 0 && strpos($account->name, 'osr') !== 0)
      ) {
        // Don't hide the current user (Site Owner).
        if ($user->uid != $account->uid) {
          unset($view->result[$x]);
        }
      }
      next($users);
    }
  }
}

/**
 * Implements hook_form_FORM_ID_alter().
 *
 * Don't allow users to delete an account and its content.
 */
function cu_users_form_user_cancel_confirm_form_alter(&$form, &$form_state) {
  unset($form['user_cancel_method']['user_cancel_delete']);
  unset($form['user_cancel_confirm']);
}

/**
 * Implements hook_user_presave().
 */
function cu_users_user_presave(&$edit, $account, $category) {

  // Need to get the role IDs to compare later.
  // The roles are ordered from lowest to highest permission level.
  $core_role_ids = [];
  $core_roles = [
    'edit_my_content',
    'edit_only',
    'content_editor',
    'site_editor',
    'site_owner',
    'administrator',
    'developer'
  ];
  foreach ($core_roles as $val) {
    $temp_role = user_role_load_by_name($val);
    if (isset($temp_role->rid)) {
      $core_role_ids[$temp_role->rid] = $temp_role->name;
    }
  }

  // Loop through roles being saved on user and reduce them to the highest permissioned role.
  $temp_roles = $edit['roles'] ?? [];
  $conflicting_roles = FALSE;
  $remaining_core_roles = [];
  foreach ($temp_roles as $val) {
    // Authenticated users key is 2 but value is TRUE. All roles will have role ID 2, a.k.a authenticated user.
    if ($val !== TRUE && array_key_exists($val, $core_role_ids)) {

      // Filter the roles being saved to make sure the user always has one left.
      $remaining_core_roles = array_filter($edit['roles'], function ($val2) use ($core_role_ids) {
        return array_key_exists($val2, $core_role_ids);
      });

      // Remove all but the last core user role.
      if (count($remaining_core_roles) === 1) {
        break;
      }
      // We only reach this point if two core roles are selected.
      $conflicting_roles = TRUE;
      unset($edit['roles'][$val]);
    }
  }

  // If conflicting roles, send a message to the user about what happened.
  if ($conflicting_roles) {
    $role_id = array_shift($remaining_core_roles);
    drupal_set_message("Only one Express core role can be assigned to a user. The highest role of \"$core_role_ids[$role_id]\" was saved for $account->name.", 'error');
  }
}

/**
 * Implements hook_user_update().
 *
 * Save a message to the log when a user is updated containing the updated info.
 */
function cu_users_user_update(&$edit, $account, $category) {
  $user_vars = array(
    '%uid' => $account->uid,
    '%name' => $account->name,
    '%mail' => $account->mail,
    '%created' => $account->created,
    '%roles' => implode(',', $account->roles),
  );

  watchdog('cu_user_logs', 'User account saved. UID: %uid name: %name mail: %mail created: %created roles: %roles', $user_vars);

  // If the user is coming from Fedauth, then we need to start the request over again.
  // When the session is destroyed on logout, the next request sends back user info in the session,
  // but it is only used on the next request.
  // Without redirecting the user, they will get an access denied.
  if (strpos($_SERVER['HTTP_REFERER'], 'https://fedauth.colorado.edu') === 0) {
    // Go to current request with new session information.
    drupal_goto($_GET['q']);
  }
}

/**
 * Implements hook_pathauto_pattern_alter().
 *
 * @param string $pattern
 *   Current Pathauto pattern to examine.
 * @param array $context
 *   An associative array of additional options. See API hook docblock.
 */
function cu_users_pathauto_pattern_alter(string &$pattern, array $context) {
  // If the pattern is for user aliases then make the pattern empty so that no
  // user aliases are ever created.
  if ($pattern === 'users/[user:name]') {
    $pattern = '';
  }
}

/**
 * Implements hook_user_insert().
 *
 * Save a message to the log when a user is inserted containing the new info.
 */
function cu_users_user_insert(&$edit, $account, $category) {
  $user_vars = array(
    '%uid' => $account->uid,
    '%name' => $account->name,
    '%mail' => $account->mail,
    '%created' => $account->created,
    '%roles' => implode(',', $account->roles),
  );

  watchdog('cu_user_logs', 'User account created. UID: %uid name: %name mail: %mail created: %created roles: %roles', $user_vars);
}

/**
 * Lookup LDAP user via email (from cu_ldap.module).
 */
function cu_users_ldap_email_lookup($email) {
  // @TODO: replace hardcoded values with configuration from LDAP settings

  // Load the user's entry in LDAP.
  $link_identifier = ldap_connect('directory.colorado.edu');
  $base_dn = "dc=colorado,dc=edu";
  $filter = "mail=" . $email;
  $result_identifier = ldap_search($link_identifier, $base_dn, $filter);
  $ldap_entries = ldap_get_entries($link_identifier, $result_identifier);

  return $ldap_entries;
}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function cu_users_form_user_external_invite_form_alter(&$form, &$form_id, &$form_state) {
  $form['#validate'][] = 'cu_users_form_validate';
  // $form['#submit'][] = 'cu_users_override_external_invite_submit';
}

/**
 * Validation handler for invite_form.
 *
 * Ensures email addresses are in valid format.
 */
function cu_users_form_validate(&$form, &$form_state) {

  $email_value = $form_state['values']['email'];
  // Split on , or line break.
  $emails = preg_split("/[\r\n,\s]+/", $email_value, -1, PREG_SPLIT_NO_EMPTY);

  $site_owner_role = user_role_load_by_name('site_owner');
  $site_owner_count = db_query('SELECT COUNT(uid) FROM {users_roles} WHERE rid = :rid', [':rid' => $site_owner_role->rid])->fetchCol();

  $final_site_owner_count = $site_owner_count[0];
  if ($form_state["values"]["rid"] == $site_owner_role->rid) {
    $final_site_owner_count = count($emails) + $site_owner_count[0];
  }

  $limit = (int) variable_get('express_permissions_owner_cap', 5);
  if ($final_site_owner_count >= $limit) {
    $users_in_role = express_permissions_get_site_owners();
    form_set_error('email', t("You can only assign {$limit} users as a Site Owner. Please check the current list of Site Owners and resend updated invites."));
  }

//
//  // Get emails from all users.
//  $email_list_query = db_query('SELECT mail FROM {users}')->fetchCol();
//  $email_list = [];
//  foreach ($email_list_query as $key => $item) {
//    $item = strtolower($item);
//    $email_list[$key] = $item;
//  }
//
//  // Get all usernames from users.
//  $username_list_query = db_query('SELECT name FROM {users}')->fetchCol();
//  $username_list = [];
//  foreach ($username_list_query as $key => $item) {
//    $item = strtolower($item);
//    $username_list[$key] = $item;
//  }
//
//  $error = FALSE;
//  foreach ($emails as $mail) {
//    $parts = explode("@", $mail);
//    $email_id = $parts[0];
//    if (!valid_email_address($mail)) {
//      $error = TRUE;
//      form_set_error('email', t('Incorrect email address (%mail). No invites were sent.', array('%mail' => $mail)));
//    } else if (in_array(strtolower($mail), $email_list)) {
//      $error = TRUE;
//      form_set_error('email', t('This email address is already associated with an account (%mail). No invites were sent.', array('%mail' => $mail)));
//    } else if (in_array($email_id, $username_list)) {
//      $error = TRUE;
//      form_set_error('email', t('This user is already associated with an account (%mail). No invites were sent.', array('%mail' => $mail)));
//    }
//    else {
//      $load = _user_external_invite_load_invite($mail);
//      if (isset($load['mail'])) {
//        form_set_error('email', t('Email address (%mail) has already been invited. No invites were sent.', array('%mail' => $mail)));
//      }
//    }
//  }
//  if (!$error) {
//    $form_state['values']['parsed_mails'] = $emails;
//  }
}

/**
 * Custom submit handler for external invite override.
 */
function cu_users_override_external_invite_submit(&$form, &$form_state) {
  $email_values = strtolower($form_state['values']['email']);
  $emails = preg_split("/[\r\n,\s]+/", $email_values, -1, PREG_SPLIT_NO_EMPTY);

  $rid = $form_state['values']['rid'];

  if (!empty($emails)) {
    foreach ($emails as $email) {
      $output = cu_users_ldap_email_lookup($email);
      $parts = explode("@", $output[0]['cuedupersonemailhome'][0]);
      $username = $parts[0];
      $ldap_mail_return = strtolower($output[0]['mail'][0]);

      if (!empty($output) && !empty($ldap_mail_return) && $email == $ldap_mail_return) {
        $new_user = array(
          'name' => $username,
          'pass' => $username . strrev($username),
          'mail' => $email,
          'timezone' => 'America/Denver',
          'status' => 1,
          'init' => $email,
          'roles' => array(
            DRUPAL_AUTHENTICATED_RID => 'authenticated user',
            $rid => 'n/a',
          ),
        );

        // The first parameter is sent blank so a new user is created.
        user_save('', $new_user);
      }
    }
  }
}

/**
 * Implements hook_user_external_invite_pre_grant_invite().
 *
 * @param $account
 * @param $grant_rid
 *
 * @return string
 */
function cu_users_user_external_invite_pre_grant_invite($account, $grant_rid) {
  $site_owner_role = user_role_load_by_name('site_owner');
  $site_owner_count = db_query('SELECT COUNT(uid) FROM {users_roles} WHERE rid = :rid', [':rid' => $site_owner_role->rid])->fetchCol();

  if ( $site_owner_count[0] >= variable_get('express_permissions_owner_cap', 3)) {
    return 'You can only assign three users as a Site Owner. You were not granted a new role.';
  }
}
